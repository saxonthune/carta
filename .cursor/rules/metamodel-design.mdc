---
description: Three-level metamodel architecture
globs: ["**/constructs/**", "**/components/fields/**", "**/components/FieldDefinitionEditor*"]
---

# The Dual-Mandate

Carta's design must fulfill two objectives in tension:

**1. Properly Bounded Modeling Capability**
Users must be able to model any domain (software architecture, sentence diagramming, circuits) at any granularity (abstract to highly detailed). The M2 primitives must be flexible enough to express diverse domains, yet restrictive enough that users don't drown in options or create muddled models. There is a "sweet spot" between too permissive and too restrictive.

**2. Semantically Sufficient Compilation**
The model state must compile to instructions an AI agent can act on—generating code, explanations, or other artifacts. This requires sufficient semantic data to differentiate instances, relationships, and schema. If an AI cannot produce quality output, the failure is either: (a) compilation lost structure, (b) the user didn't add enough meaning (but had the capability to), or (c) the metamodel was too complex to use effectively.

**Design decisions must satisfy both objectives.** When evaluating changes, ask: Does this expand modeling capability without adding confusion? Does this preserve or enhance semantic clarity in compilation?

---

# Metamodel Design: Three-Level Architecture

Carta uses a classic three-level metamodel (M2/M1/M0) to provide flexibility while maintaining type safety.

## Levels Overview

```
M2 (Designer-fixed)     M1 (User-defined)           M0 (Instances)
─────────────────────   ─────────────────────────   ─────────────────────
DataKind: string,       Registries:                 ConstructInstance:
  number, boolean,        - Constructs                - type → Construct
  date, enum              - Deployables               - deployable? → Deployable
                          - Ports                     - semanticId (required)
PortDefinition:                                       - values: {field → value}
  flow-in, flow-out,   Construct:                    - connections[]
  parent, child,         - displayName, description
  symmetric              - displayField
                         - fields[]
                         - ports[]
```

## M2: Fixed Primitives

These types are fixed at design time and cannot be changed by users.

### DataKind
The five primitive data types for field values:

| Kind | Description | Example Values |
|------|-------------|----------------|
| `string` | Text data | "Hello", "/api/users" |
| `number` | Numeric data | 42, 3.14 |
| `boolean` | True/false | true, false |
| `date` | Date values | "2024-01-15" |
| `enum` | Fixed choices | "GET", "POST", "PUT" |

### DisplayHint
Presentation hints for string fields (optional):

| Hint | Renders As |
|------|------------|
| (none) | Single-line input |
| `multiline` | Textarea |
| `code` | Monospace textarea |
| `password` | Password input |
| `url` | URL input |
| `color` | Color picker |

### PortDefinition
Fixed port types with compatibility rules (see `ports-and-connections.mdc`):

| Port Type | Compatible With | Default Position |
|-----------|-----------------|------------------|
| `flow-in` | flow-out, symmetric | left |
| `flow-out` | flow-in, symmetric | right |
| `parent` | child, symmetric | top |
| `child` | parent, symmetric | bottom |
| `symmetric` | any | right |

```typescript
interface PortDefinition {
  id: string;              // 'flow-in', 'flow-out', etc.
  label: string;
  description: string;
  compatibleWith?: string[]; // undefined = any port
  defaultPosition: PortPosition;
  color: string;
}
```

## M1: User-Defined Schemas

Users define construct types via the Schema Editor. Each construct schema specifies:

```typescript
interface ConstructSchema {
  type: string;              // Unique identifier
  displayName: string;       // Human-readable name
  color: string;             // Visual accent
  description?: string;      // AI compilation context
  displayField?: string;     // Field to use as node title
  fields: FieldDefinition[]; // Data fields
  ports?: PortConfig[];      // Connection points
  compilation: CompilationConfig;
}
```

### displayField
Specifies which field's value to show as the node title. If not set or empty, falls back to `semanticId`.

```typescript
// Controller schema with displayField
{
  type: 'controller',
  displayName: 'REST Controller',
  displayField: 'route',  // Node title shows the route value
  fields: [
    { name: 'route', type: 'string', ... },
    ...
  ]
}
```

### FieldDefinition

```typescript
interface FieldDefinition {
  name: string;           // Internal key
  label: string;          // Display label
  type: DataKind;         // One of the M2 primitives
  description?: string;   // AI context for compilation
  options?: string[];     // For enum type only
  displayHint?: DisplayHint; // For string type only
  default?: unknown;
  placeholder?: string;
}
```

### PortConfig

```typescript
interface PortConfig {
  id: string;                    // Unique within construct
  portType: string;              // References PortDefinition.id
  position: PortPosition;
  offset: number;
  label: string;
  description?: string;
  suggestedTypes?: string[];
  suggestedPorts?: string[];
  dataType?: string;
}
```

## M0: Construct Instances

Instances live on the React Flow canvas as nodes:

```typescript
interface ConstructNodeData {
  constructType: string;     // References schema.type
  semanticId: string;        // Required, primary identifier
  values: ConstructValues;   // Field values
  connections?: ConnectionValue[];
  deployableId?: string | null;
  isExpanded?: boolean;
}
```

**Note:** There is no `name` field. Node titles are derived using:
1. `displayField` value from schema (if set and has value)
2. `semanticId` as fallback

## Design Principles

### 1. No Embedded Tables
Previously, fields like `params` (on Controller) or `columns` (on Table) used a `table` field type with embedded rows.

**New approach:** Use child constructs connected via parent-child ports.

```
Old: Controller.params = [{name: "id", in: "path", ...}]
New: Controller ←─parent─ ApiParameter instances
```

Benefits:
- Visual representation of structure
- Consistent editing experience
- Reusable parameter/column definitions
- Cleaner separation of concerns

### 2. DataKind is Exhaustive
Every field must have exactly one of the five DataKinds. There are no "special" field types like `table` or `connection`.

### 3. DisplayHint is Optional
DisplayHint only affects rendering, not data storage. A `string` field with `displayHint: 'code'` stores the same data as one without—just renders differently.

### 4. Description for AI Context
The `description` field on both schemas and field definitions provides context for AI compilation. Use it to explain what the field represents semantically.

### 5. Semantic ID is Primary Identifier
`semanticId` is always required and serves as the primary identifier for constructs. Generated automatically with pattern `{type}-{timestamp}{random}`.

## Child Construct Patterns

### API Parameter (child of Controller)
```typescript
{
  type: 'api-parameter',
  displayField: 'name',
  fields: [
    { name: 'name', type: 'string' },
    { name: 'location', type: 'enum', options: ['path', 'query', 'header', 'body'] },
    { name: 'dataType', type: 'enum', options: ['string', 'number', 'boolean', 'object', 'array'] },
    { name: 'required', type: 'boolean' },
  ],
  ports: [{ id: 'parent', portType: 'parent', ... }],
}
```

### Column (child of Table)
```typescript
{
  type: 'column',
  displayField: 'name',
  fields: [
    { name: 'name', type: 'string' },
    { name: 'dataType', type: 'enum', options: ['VARCHAR', 'INT', ...] },
    { name: 'primaryKey', type: 'boolean' },
    { name: 'nullable', type: 'boolean' },
  ],
  ports: [{ id: 'parent', portType: 'parent', ... }],
}
```

## Compiler Integration

Formatters find child constructs by traversing connections:

```typescript
// Find child parameters for a controller
const childParams = allNodes.filter(n =>
  n.constructType === 'api-parameter' &&
  n.connections?.some(c =>
    c.targetSemanticId === controller.semanticId &&
    c.portId === 'parent'
  )
);
```

## Registry Pattern

Both Construct schemas and Deployables use the generic `Registry<T>` interface:

```typescript
interface Registry<T extends RegistryItem> {
  get(id: string): T | undefined;
  getAll(): T[];
  add(item: Omit<T, 'id'>): T;
  update(id: string, updates: Partial<T>): T | undefined;
  remove(id: string): boolean;
  clear(): void;
}
```

See `registry-base.ts` for the `BaseRegistry` implementation with localStorage persistence.

## Port Registry

The `PortRegistry` manages port type definitions and validates connections:

```typescript
// src/constructs/portRegistry.ts
export class PortRegistry {
  get(id: string): PortDefinition | undefined;
  getAll(): PortDefinition[];
  canConnect(sourcePortType: string, targetPortType: string): boolean;
  getColor(portType: string): string;
}

export const portRegistry = new PortRegistry();
```

## Display Utilities

Node titles are computed via helper function:

```typescript
// src/utils/displayUtils.ts
export function getDisplayName(
  data: ConstructNodeData,
  schema: ConstructSchema | undefined
): string {
  if (schema?.displayField && data.values[schema.displayField]) {
    return String(data.values[schema.displayField]);
  }
  return data.semanticId;
}
```
