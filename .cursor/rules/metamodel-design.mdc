---
description: Three-level metamodel architecture
globs: ["**/constructs/**", "**/components/fields/**", "**/components/FieldSchemaEditor*", "**/components/PortSchemaEditor*"]
---

# The Dual-Mandate

Carta's design must fulfill two objectives in tension:

**1. Properly Bounded Modeling Capability**
Users must be able to model any domain (software architecture, sentence diagramming, circuits) at any granularity (abstract to highly detailed). The M2 primitives must be flexible enough to express diverse domains, yet restrictive enough that users don't drown in options or create muddled models. There is a "sweet spot" between too permissive and too restrictive.

**2. Semantically Sufficient Compilation**
The model state must compile to instructions an AI agent can act on—generating code, explanations, or other artifacts. This requires sufficient semantic data to differentiate instances, relationships, and schema. If an AI cannot produce quality output, the failure is either: (a) compilation lost structure, (b) the user didn't add enough meaning (but had the capability to), or (c) the metamodel was too complex to use effectively.

**Design decisions must satisfy both objectives.** When evaluating changes, ask: Does this expand modeling capability without adding confusion? Does this preserve or enhance semantic clarity in compilation?

---

# Metamodel Design: Three-Level Architecture

Carta uses a classic three-level metamodel (M2/M1/M0) to provide flexibility while maintaining type safety.

## Levels Overview

```
M2 (Designer-fixed)     M1 (User-defined)           M0 (Instances)
─────────────────────   ─────────────────────────   ─────────────────────
DataKind: string,       Stored in Yjs Y.Doc:        ConstructInstance:
  number, boolean,        - Construct schemas         - type → Construct
  date, enum              - Deployables               - deployable? → Deployable
                          - Port Schemas              - semanticId (required)
Polarity: source,         - Schema Groups             - values: {field → value}
  sink, bidirectional,                                - connections[]
  relay, intercept     PortSchema:
                         - polarity (5 values)
                         - compatibleWith
                         - defaultPosition
                         - allowsGrouping

                       Construct:
                         - displayName, description
                         - displayField
                         - fields: FieldSchema[]
                         - ports: PortConfig[]
```

## M2: Fixed Primitives

These types are fixed at design time and cannot be changed by users.

### DataKind
The five primitive data types for field values:

| Kind | Description | Example Values |
|------|-------------|----------------|
| `string` | Text data | "Hello", "/api/users" |
| `number` | Numeric data | 42, 3.14 |
| `boolean` | True/false | true, false |
| `date` | Date values | "2024-01-15" |
| `enum` | Fixed choices | "GET", "POST", "PUT" |

### DisplayHint
Presentation hints for string fields (optional):

| Hint | Renders As |
|------|------------|
| (none) | Single-line input |
| `multiline` | Textarea |
| `code` | Monospace textarea |
| `password` | Password input |
| `url` | URL input |
| `color` | Color picker |

### Polarity
Polarity determines connection direction semantics (5 values):

| Polarity | Meaning | Examples |
|----------|---------|----------|
| `source` | Initiates connections | flow-out, parent |
| `sink` | Receives connections | flow-in, child |
| `bidirectional` | Can both initiate and receive | symmetric |
| `relay` | Pass-through output, bypasses type checking | relay |
| `intercept` | Pass-through input, bypasses type checking | intercept |

**Two-step validation in `canConnect()`:**
1. **Direction check**: relay maps to source, intercept maps to sink. Same-direction pairs blocked.
2. **compatibleWith check**: Skipped if either side is relay, intercept, or bidirectional. For plain source+sink, at least one side must list the other in compatibleWith.

### PortSchema (M1 Layer)
Port schemas are now user-editable M1 entities (like ConstructSchema):

| Port Type | Polarity | Compatible With | Default Position |
|-----------|----------|-----------------|------------------|
| `flow-in` | sink | `['flow-out']` | left |
| `flow-out` | source | `['flow-in']` | right |
| `parent` | source | `['child']` | bottom |
| `child` | sink | `['parent']` | top |
| `symmetric` | bidirectional | `[]` (skips check) | right |
| `intercept` | intercept | `[]` (skips check) | left |
| `relay` | relay | `[]` (skips check) | right |

```typescript
interface PortSchema {
  id: string;                    // 'flow-in', 'flow-out', etc.
  displayName: string;
  semanticDescription: string;   // AI compilation context
  polarity: Polarity;            // 'source' | 'sink' | 'bidirectional' | 'relay' | 'intercept'
  compatibleWith: string[];      // port IDs or '*' wildcard (skipped for relay/intercept/bidirectional)
  expectedComplement?: string;   // UI hint only
  defaultPosition: PortPosition;
  color: string;
  allowsGrouping?: boolean;      // Enable visual grouping via virtual parent nodes
}
```

Port schemas are stored in the document store and editable via the Ports tab.

## M1: User-Defined Schemas

Users define construct types via the Schema Editor. Each construct schema specifies:

```typescript
interface ConstructSchema {
  type: string;              // Unique identifier
  displayName: string;       // Human-readable name
  color: string;             // Visual accent
  description?: string;      // AI compilation context
  displayField?: string;     // Field to use as node title
  fields: FieldSchema[];     // Data fields
  ports?: PortConfig[];      // Connection points
  compilation: CompilationConfig;
  backgroundColorPolicy?: 'defaultOnly' | 'tints' | 'any';  // Controls instance color picker
  portDisplayPolicy?: 'inline' | 'collapsed';                 // Controls port visibility
}
```

### backgroundColorPolicy

Controls how users can customize the background color of construct instances:

- **`defaultOnly`** (default): No color picker shown, instances use schema color
- **`tints`**: Shows 7 tint swatches derived from schema color (light to dark via HSL)
- **`any`**: Shows full color picker, users can select any hex color

When set, instances can override their background color via the `instanceColor` field. This is visual-only and not included in compilation.

### portDisplayPolicy

Controls how port handles are displayed on construct nodes:

- **`inline`** (default): Port handles visible on node edges, positioned by offset
- **`collapsed`**: Ports hidden, click icon in header to reveal popover picker

Collapsed ports are useful for note-like constructs or simple nodes where connections are secondary to content.

### displayField
Specifies which field's value to show as the node title. If not set or empty, falls back to `semanticId`.

```typescript
// Controller schema with displayField
{
  type: 'controller',
  displayName: 'REST Controller',
  displayField: 'route',  // Node title shows the route value
  fields: [
    { name: 'route', type: 'string', ... },
    ...
  ]
}
```

### FieldSchema

```typescript
interface FieldSchema {
  name: string;           // Internal key
  label: string;          // Display label
  type: DataKind;         // One of the M2 primitives
  description?: string;   // AI context for compilation
  options?: string[];     // For enum type only
  displayHint?: DisplayHint; // For string type only
  default?: unknown;
  placeholder?: string;
  displayInMap?: boolean; // Show this field in the map node summary
}
```

### PortConfig

```typescript
interface PortConfig {
  id: string;                    // Unique within construct
  portType: string;              // References PortDefinition.id
  position: PortPosition;
  offset: number;
  label: string;
  description?: string;
  suggestedTypes?: string[];
  suggestedPorts?: string[];
  dataType?: string;
  allowsGrouping?: boolean;      // Enable visual grouping via virtual parent nodes
}
```

## M0: Construct Instances

Instances live on the React Flow canvas as nodes:

```typescript
interface ConstructNodeData {
  constructType: string;     // References schema.type
  semanticId: string;        // Required, primary identifier
  values: ConstructValues;   // Field values
  connections?: ConnectionValue[];
  deployableId?: string | null;
  instanceColor?: string;    // Visual-only color override (not compiled)
  isExpanded?: boolean;
}
```

**Note:** There is no `name` field. Node titles are derived using:
1. `displayField` value from schema (if set and has value)
2. `semanticId` as fallback

**Visual Customization:** The `instanceColor` field allows per-instance background color overrides. This is visual-only and not included in compilation. Whether users can set this depends on the schema's `backgroundColorPolicy` setting.

### Virtual Parent Nodes

Virtual parent nodes provide visual grouping for child constructs on the canvas. They are **not compiled** -- the compiler filters them out.

```typescript
interface VirtualParentNodeData {
  isVirtualParent: true;
  parentNodeId: string;            // Tech ID of actual parent construct
  parentSemanticId: string;
  groupingPortId: string;          // Port on parent with allowsGrouping
  complementPortId: string;        // Expected port type on children
  label: string;
  color: string;
  collapseState: 'expanded' | 'no-edges' | 'collapsed';
}
```

Created via `useGraphOperations().createVirtualParent()` when a port has `allowsGrouping: true`.

## Design Principles

### 1. No Embedded Tables
Previously, fields like `params` (on Controller) or `columns` (on Table) used a `table` field type with embedded rows.

**New approach:** Use child constructs connected via parent-child ports.

```
Old: Controller.params = [{name: "id", in: "path", ...}]
New: Controller ←─parent─ ApiParameter instances
```

Benefits:
- Visual representation of structure
- Consistent editing experience
- Reusable parameter/column definitions
- Cleaner separation of concerns

### 2. DataKind is Exhaustive
Every field must have exactly one of the five DataKinds. There are no "special" field types like `table` or `connection`.

### 3. DisplayHint is Optional
DisplayHint only affects rendering, not data storage. A `string` field with `displayHint: 'code'` stores the same data as one without—just renders differently.

### 4. Description for AI Context
The `description` field on both schemas and field definitions provides context for AI compilation. Use it to explain what the field represents semantically.

### 5. Dual Identity System
Construct instances use two separate identifiers:
- **Technical ID** (`Node.id`): Immutable UUID from `crypto.randomUUID()`, used internally by React Flow and Yjs as the Y.Map key. Never exposed to users, never changes.
- **Semantic ID** (`semanticId`): Human/AI-readable identifier used in connections and compilation. Generated as `{type}-{timestamp}{random}` (e.g., "controller-1738004567abc"). Can be changed by users, which triggers cascade updates to all referencing connections (see `yjsAdapter.ts:350-377`).

## Child Construct Patterns

### API Parameter (child of Controller)
```typescript
{
  type: 'api-parameter',
  displayField: 'name',
  fields: [
    { name: 'name', type: 'string' },
    { name: 'location', type: 'enum', options: ['path', 'query', 'header', 'body'] },
    { name: 'dataType', type: 'enum', options: ['string', 'number', 'boolean', 'object', 'array'] },
    { name: 'required', type: 'boolean' },
  ],
  ports: [{ id: 'parent', portType: 'parent', ... }],
}
```

### Column (child of Table)
```typescript
{
  type: 'column',
  displayField: 'name',
  fields: [
    { name: 'name', type: 'string' },
    { name: 'dataType', type: 'enum', options: ['VARCHAR', 'INT', ...] },
    { name: 'primaryKey', type: 'boolean' },
    { name: 'nullable', type: 'boolean' },
  ],
  ports: [{ id: 'parent', portType: 'parent', ... }],
}
```

## Compiler Integration

Formatters find child constructs by traversing connections:

```typescript
// Find child parameters for a controller
const childParams = allNodes.filter(n =>
  n.constructType === 'api-parameter' &&
  n.connections?.some(c =>
    c.targetSemanticId === controller.semanticId &&
    c.portId === 'parent'
  )
);
```

## State Access Pattern

All document state (schemas, deployables, port schemas, nodes, edges) is accessed via the `useDocument()` hook:

```typescript
// In any component
const { schemas, deployables, portSchemas, getSchema, addSchema } = useDocument();

// All operations go through adapter methods
addSchema(newSchema);
const schema = getSchema('my-type');
```

No singleton registries—all state flows through the DocumentAdapter interface implemented by YjsAdapter. Port schemas and construct schemas are stored in the Y.Doc.

## Port Registry

The `PortRegistry` manages port schemas with polarity-based validation. It receives schemas as a parameter (not a singleton):

```typescript
// src/constructs/portRegistry.ts
export class PortRegistry {
  constructor(schemas: PortSchema[] = DEFAULT_PORT_SCHEMAS);
  get(id: string): PortSchema | undefined;
  getAll(): PortSchema[];
  setSchemas(schemas: PortSchema[]): void;  // Update internal schemas
  canConnect(fromPortType: string, toPortType: string): boolean;  // Polarity-based
  getColor(portType: string): string;
  register(schema: PortSchema): void;
  remove(id: string): boolean;
  getDefaultPosition(portType: string): PortPosition;
}

export const portRegistry = new PortRegistry();

// Sync registry with document portSchemas
export function syncWithDocumentStore(portSchemas?: PortSchema[]): void;
```

Port schemas are stored in the Yjs document alongside construct schemas and deployables. Components access them via `useDocument()`:

```typescript
const { portSchemas, addPortSchema, updatePortSchema } = useDocument();
```

Users can create custom port types via the Ports tab.

## Display Utilities

Node titles are computed via helper function:

```typescript
// src/utils/displayUtils.ts
export function getDisplayName(
  data: ConstructNodeData,
  schema: ConstructSchema | undefined
): string {
  if (schema?.displayField && data.values[schema.displayField]) {
    return String(data.values[schema.displayField]);
  }
  return data.semanticId;
}
```
