---
description: Yjs CRDT library for real-time collaborative editing - NOW FULLY INTEGRATED
globs: ["**/*.tsx", "**/*.ts", "**/*.jsx", "**/*.js"]
---

# Yjs Real-Time Collaboration

## CURRENT STATUS: FULLY INTEGRATED

Carta now uses Yjs as the single source of truth for ALL state management. Key points:

- **Single source of truth** - Yjs Y.Doc is the only state store (no Zustand, no dual state)
- **No localStorage adapter** - Removed completely
- **No legacy mode** - Only 'local' and 'shared' modes exist
- **Always Yjs** - State always flows through Y.Doc with y-indexeddb persistence
- **Access pattern** - Components use `useDocument()` hook to access state via DocumentAdapter
- **No singleton registries** - Removed registry.ts, deployables.ts singletons
- **Hosting modes** - `VITE_STATIC_MODE=true` (static mode: single local document) or false (server mode: collaboration)
- **URL routing** - Server mode uses `?doc={documentId}` parameter for document selection
- **Undo/Redo** - Uses Y.UndoManager (local per-user, not shared across clients)
- **Import flow** - Clears entire document before importing (like Excalidraw)

## Architecture

```
Components
    ↓
useDocument() hook (src/hooks/useDocument.ts)
    ↓
DocumentContext (src/contexts/DocumentContext.tsx)
    ↓
YjsAdapter (src/stores/adapters/yjsAdapter.ts)
    ↓
Y.Doc (always active, single source of truth)
    ↓
y-indexeddb (local persistence)
    ↓
y-websocket (optional, for shared mode)
```

All state operations flow through the adapter interface. No direct access to singleton registries.

Yjs is a CRDT (Conflict-free Replicated Data Type) library for building collaborative applications. Changes sync automatically across clients without conflicts.

## Core Concepts

| Concept | Description |
|---------|-------------|
| Y.Doc | The shared document containing all collaborative state |
| Shared Types | Y.Array, Y.Map, Y.Text - observable, conflict-free data structures |
| Providers | Network/persistence layers (y-websocket, y-indexeddb, y-webrtc) |
| Updates | Binary patches that can be applied in any order, multiple times |
| State Vector | Tracks what each client has seen for efficient sync |

## Quick Start

```bash
npm i yjs y-websocket
```

```typescript
import * as Y from 'yjs'
import { WebsocketProvider } from 'y-websocket'

const ydoc = new Y.Doc()

// Connect to sync server
const provider = new WebsocketProvider('wss://your-server.com', 'document-id', ydoc)

// Get shared types (created on first access)
const yarray = ydoc.getArray('my-array')
const ymap = ydoc.getMap('my-map')
const ytext = ydoc.getText('my-text')

// Observe changes (local and remote)
yarray.observe(event => {
  console.log('array changed:', yarray.toArray())
})

// Make changes
yarray.insert(0, ['hello', 'world'])
```

---

# Shared Types

## Y.Array

Efficient insert/delete at any position. Internally uses a linked list.

```typescript
const yarray = ydoc.getArray('items')

// Creation
const fromData = Y.Array.from(['a', 'b', 'c'])

// Mutations
yarray.insert(0, ['first', 'second'])  // Insert at index
yarray.push(['last'])                   // Append
yarray.unshift(['first'])               // Prepend
yarray.delete(0, 2)                     // Delete range

// Access
yarray.get(0)                           // Get by index
yarray.slice(0, 5)                      // Get range
yarray.length                           // Length
yarray.toArray()                        // Convert to JS array
yarray.toJSON()                         // Deep convert to JSON

// Iteration
for (const item of yarray) { }
yarray.forEach((value, index) => { })
yarray.map(item => transform(item))
```

## Y.Map

Key-value store with string keys.

```typescript
const ymap = ydoc.getMap('config')

// Mutations
ymap.set('key', 'value')
ymap.set('nested', new Y.Map())  // Nested shared types
ymap.delete('key')
ymap.clear()

// Access
ymap.get('key')
ymap.has('key')
ymap.size
ymap.toJSON()

// Iteration
for (const [key, value] of ymap) { }
ymap.forEach((value, key) => { })
ymap.entries()
ymap.keys()
ymap.values()
```

## Y.Text

Optimized for collaborative text editing with formatting support.

```typescript
const ytext = ydoc.getText('content')

// Mutations
ytext.insert(0, 'Hello')
ytext.insert(5, ' World', { bold: true })  // With formatting
ytext.delete(0, 5)
ytext.format(0, 5, { italic: true })       // Apply formatting to range

// Access
ytext.toString()
ytext.length
ytext.toDelta()  // Quill Delta format

// Apply Quill Delta
ytext.applyDelta([
  { insert: 'Hello ' },
  { insert: 'World', attributes: { bold: true } }
])
```

## Nesting Types

Shared types can be nested, but each instance can only exist once in the document.

```typescript
const ymap = ydoc.getMap('data')
const nestedArray = new Y.Array()

nestedArray.insert(0, ['a', 'b'])
ymap.set('items', nestedArray)

ymap.get('items') === nestedArray  // true

// ERROR: Can't add same instance twice
ymap.set('copy', nestedArray)  // Throws!
```

---

# Observing Changes

## Type Observers

```typescript
// Observe direct changes to a type
yarray.observe((event, transaction) => {
  console.log('Changed:', event.changes)
  console.log('Origin:', transaction.origin)
})

// Observe changes to type AND all nested children
ymap.observeDeep((events, transaction) => {
  events.forEach(event => {
    console.log('Path:', event.path)
    console.log('Target:', event.target)
  })
})

// Remove observers
yarray.unobserve(handler)
ymap.unobserveDeep(handler)
```

## Document Events

```typescript
// Listen to all updates (for syncing)
ydoc.on('update', (update: Uint8Array, origin: any) => {
  // Send update to other clients
  broadcastUpdate(update)
})

// Transaction lifecycle
ydoc.on('beforeTransaction', (transaction, doc) => { })
ydoc.on('afterTransaction', (transaction, doc) => { })
```

---

# Transactions

Bundle multiple changes into a single update event.

```typescript
// Without transaction: triggers multiple events
yarray.insert(0, ['a'])
ymap.set('key', 'value')

// With transaction: single event
ydoc.transact(() => {
  yarray.insert(0, ['a'])
  ymap.set('key', 'value')
}, 'my-origin')  // Optional origin for tracking
```

---

# Document Updates

Updates are commutative and idempotent - apply in any order, multiple times.

## Sync Two Documents

```typescript
const doc1 = new Y.Doc()
const doc2 = new Y.Doc()

// Listen and apply updates bidirectionally
doc1.on('update', update => Y.applyUpdate(doc2, update))
doc2.on('update', update => Y.applyUpdate(doc1, update))

// Now changes sync automatically
doc1.getArray('data').insert(0, ['hello'])
doc2.getArray('data').get(0)  // 'hello'
```

## Full State Sync

```typescript
// Exchange complete state
const state1 = Y.encodeStateAsUpdate(doc1)
const state2 = Y.encodeStateAsUpdate(doc2)

Y.applyUpdate(doc1, state2)
Y.applyUpdate(doc2, state1)
```

## Differential Sync (Efficient)

Only send what the other client is missing.

```typescript
// Get state vectors
const sv1 = Y.encodeStateVector(doc1)
const sv2 = Y.encodeStateVector(doc2)

// Compute diffs
const diff1 = Y.encodeStateAsUpdate(doc1, sv2)  // What doc2 needs from doc1
const diff2 = Y.encodeStateAsUpdate(doc2, sv1)  // What doc1 needs from doc2

// Apply diffs
Y.applyUpdate(doc1, diff2)
Y.applyUpdate(doc2, diff1)
```

## Merge Updates

Combine multiple updates into one (removes duplicates, compresses).

```typescript
const mergedUpdate = Y.mergeUpdates([update1, update2, update3])
```

## Update API Reference

| Function | Description |
|----------|-------------|
| `Y.applyUpdate(doc, update, origin?)` | Apply update to document |
| `Y.encodeStateAsUpdate(doc, targetSV?)` | Encode doc state (optionally as diff) |
| `Y.encodeStateVector(doc)` | Get state vector for diff calculation |
| `Y.mergeUpdates(updates[])` | Merge updates, remove duplicates |
| `Y.diffUpdate(update, stateVector)` | Compute diff without loading doc |

---

# Providers

Combine providers for network sync + offline persistence.

```typescript
import { WebsocketProvider } from 'y-websocket'
import { WebrtcProvider } from 'y-webrtc'
import { IndexeddbPersistence } from 'y-indexeddb'

const ydoc = new Y.Doc()

// Persist locally (instant load, offline support)
const indexeddb = new IndexeddbPersistence('doc-id', ydoc)
indexeddb.whenSynced.then(() => console.log('Loaded from IndexedDB'))

// Sync via WebSocket
const websocket = new WebsocketProvider('wss://server.com', 'document-id', ydoc)

// P2P sync (works without server)
const webrtc = new WebrtcProvider('document-id', ydoc)
```

---

# Undo Manager

Selective undo/redo scoped to specific types and origins.

```typescript
const ytext = ydoc.getText('content')
const undoManager = new Y.UndoManager(ytext)

ytext.insert(0, 'hello')
undoManager.undo()  // ''
undoManager.redo()  // 'hello'

// Stop auto-merging (next change is separate undo step)
ytext.insert(0, 'a')
undoManager.stopCapturing()
ytext.insert(1, 'b')
undoManager.undo()  // 'a' (only 'b' undone)
```

## Track Specific Origins

Only undo changes from specific transaction origins.

```typescript
const undoManager = new Y.UndoManager(ytext, {
  trackedOrigins: new Set(['user-input', MyBindingClass])
})

// This change is tracked
ydoc.transact(() => ytext.insert(0, 'user typed'), 'user-input')

// This change is NOT tracked (won't be undone)
ydoc.transact(() => ytext.insert(0, 'system'), 'system')
```

## Store Metadata (Cursor Position, etc.)

```typescript
undoManager.on('stack-item-added', event => {
  event.stackItem.meta.set('cursor', getCursorPosition())
})

undoManager.on('stack-item-popped', event => {
  restoreCursorPosition(event.stackItem.meta.get('cursor'))
})
```

---

# Relative Positions

Cursor positions that survive remote edits.

```typescript
// Create relative position at index 2
const relPos = Y.createRelativePositionFromTypeIndex(ytext, 2)

// Later, after edits, convert back to absolute
const absPos = Y.createAbsolutePositionFromRelativePosition(relPos, ydoc)
if (absPos) {
  console.log(absPos.index)  // Updated index
}

// Serialize for network transmission
const encoded = Y.encodeRelativePosition(relPos)
const decoded = Y.decodeRelativePosition(encoded)

// Or use JSON
const json = JSON.stringify(relPos)
const parsed = JSON.parse(json)
```

---

# Performance Tips

## Batch Changes

```typescript
// Bad: Multiple events
items.forEach(item => yarray.push([item]))

// Good: Single event
ydoc.transact(() => {
  items.forEach(item => yarray.push([item]))
})

// Best: Single operation
yarray.insert(yarray.length, items)
```

## Use Subdocuments for Large Data

```typescript
// Main doc stays small
const mainDoc = new Y.Doc()
const projectsMap = mainDoc.getMap('projects')

// Each project is a subdocument (loaded on demand)
const projectDoc = new Y.Doc({ guid: 'project-123' })
projectsMap.set('project-123', projectDoc)
```

## Garbage Collection

```typescript
// Disable GC if you need to restore deleted content
const ydoc = new Y.Doc()
ydoc.gc = false  // Tombstones preserved
```

---

# V2 Update Format

Better compression, use for custom providers.

```typescript
// Listen for V2 updates
ydoc.on('updateV2', (update, origin) => { })

// Apply V2 updates
Y.applyUpdateV2(ydoc, update)

// Convert between formats
const v2 = Y.convertUpdateFormatV1ToV2(v1Update)
const v1 = Y.convertUpdateFormatV2ToV1(v2Update)
```

---

# CRDT Guarantees

| Property | Meaning |
|----------|---------|
| Commutative | Updates can be applied in any order |
| Idempotent | Same update can be applied multiple times safely |
| Convergent | All clients reach same state eventually |
| No Central Server | Can sync peer-to-peer |
| Offline-First | Changes merge when reconnected |

## How Yjs Handles Growth

CRDTs grow because deleted items become tombstones. Yjs optimizes:

1. **Struct Merging**: Sequential inserts merge into single struct
2. **Content Deletion**: Deleted content removed, metadata kept
3. **Garbage Collection**: Child tombstones collected when parent deleted

---

# Common Patterns

## React Integration

```typescript
const useYArray = <T>(yarray: Y.Array<T>): T[] => {
  const [items, setItems] = useState<T[]>(yarray.toArray())

  useEffect(() => {
    const handler = () => setItems(yarray.toArray())
    yarray.observe(handler)
    return () => yarray.unobserve(handler)
  }, [yarray])

  return items
}
```

## Awareness (Cursors, Presence)

```typescript
import { WebsocketProvider } from 'y-websocket'

const provider = new WebsocketProvider(url, documentId, ydoc)
const awareness = provider.awareness

// Set local state
awareness.setLocalState({
  user: { name: 'Alice', color: '#ff0000' },
  cursor: { x: 100, y: 200 }
})

// Listen to all users
awareness.on('change', () => {
  const states = awareness.getStates()  // Map<clientId, state>
})
```

## Presence with Y.Map

```typescript
const presence = ydoc.getMap('presence')

// Set your presence
presence.set(ydoc.clientID.toString(), {
  name: 'Alice',
  cursor: { line: 10, col: 5 },
  timestamp: Date.now()
})

// Clean up stale presence (e.g., every 30s)
setInterval(() => {
  const now = Date.now()
  presence.forEach((state, id) => {
    if (now - state.timestamp > 60000) {
      presence.delete(id)
    }
  })
}, 30000)
```
