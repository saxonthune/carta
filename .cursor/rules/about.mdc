---
alwaysApply: true
---

# Carta - Visual Software Architecture Editor

## Project Overview

Carta is a node-based visual editor for designing software architecture. Users can create, connect, and configure software components (called "Constructs") in a visual canvas, then compile the entire design into text output that can be fed into AI coding tools.

**Core Goal**: Bridge the gap between high-level architecture design and AI-assisted code generation by providing a visual interface that produces structured, machine-readable specifications.

## Key Libraries & Technologies

- **React 19.2** - UI framework
- **@xyflow/react 12.10** (React Flow) - Node-based visual editor with drag-drop, connections, and pan/zoom
- **Vite 7.2** - Build tool and dev server
- **TypeScript 5.9** - Type safety
- **Tailwind CSS** - Utility-first styling
- **Yjs** - CRDT-based state management with collaborative editing support
- **y-indexeddb** - Local persistence layer for Yjs documents
- **y-websocket** (optional) - WebSocket provider for real-time collaboration

## Architecture: Separation of Concerns

The system is designed with **three decoupled layers** that can evolve independently:

### 1. Visual Editor Layer (`src/App.tsx`, `src/components/`)
- Manages the React Flow canvas (nodes, edges, viewport)
- Handles user interactions (drag, connect, select, copy/paste)
- Provides UI controls (toolbar, context menus, node controls)
- Implements undo/redo functionality
- **Does NOT know** how to render specific construct types or compile them

#### UI Layout
The application uses a dual-view layout toggled via the Header:

```
┌─────────────────────────────────────────┐
│               Header                     │
│  (title, import/export, Map/Metamap)     │
├─────────────────────────────────────────┤
│                                          │
│          Map or Metamap view             │
│  (ReactFlow canvas, zoom controls,       │
│   context menus, node interactions)      │
│                                          │
│                                          │
│                                          │
│                                          │
├─────────────────────────────────────────┤
│               Footer                     │
└─────────────────────────────────────────┘
```

**Views:**
- **Map** (instance view) - ReactFlow canvas for construct instances, connections, virtual parents
- **Metamap** (schema view) - ReactFlow canvas for schema-level modeling (SchemaNode, SchemaGroupNode)

**Components:**
- **App** - Owns the layout, manages view state (Map/Metamap toggle), handles import/export, shows DocumentBrowserModal when required
- **Header** - Project title (click to edit via modal), import/export buttons, theme selector, settings menu, Map/Metamap toggle, Share button (server mode only)
  - **ProjectInfoModal** - Edit project title and description
  - **ExamplesModal** - Load bundled example .carta files from `/examples/` directory
  - **DocumentBrowserModal** - Browse/create/select documents in server mode, required mode when ?doc= missing
  - **ConnectionStatus** - Connection status indicator (server mode only)
- **Map** - ReactFlow canvas with zoom controls, node operations, context menus, SchemaCreationWizard, virtual-parent node type
  - **VirtualParentNode** - Visual grouping container for child constructs (expandable/collapsible)
  - **SchemaCreationWizard** - Multi-step wizard for creating/editing construct schemas (Basics, Fields, Ports)
  - **ContextMenu** (`src/ContextMenu.tsx`) - Shared context menu; Map view includes "Add Node Here", "Paste", node/edge ops
- **Metamap** - ReactFlow canvas for schema-level view with auto-layout
  - **SchemaNode** - Renders construct schemas with port diamonds
  - **SchemaGroupNode** - Renders schema groups
  - **MetamapConnectionModal** - Modal for creating inter-schema connections (includes port color picker)
  - **ContextMenu** (`src/ContextMenu.tsx`) - Shared context menu; Metamap view shows only "New Construct Schema" and "New Group"

### 2. Document Adapter Layer (`src/stores/`)
- DocumentAdapter interface defines contract for all state operations
- YjsAdapter (`adapters/yjsAdapter.ts`) implements adapter using Yjs Y.Doc
- DocumentContext (`contexts/DocumentContext.tsx`) manages adapter lifecycle and mode detection (static vs server)
- Schema system (`constructs/types.ts`) defines structure via `ConstructSchema`, `PortSchema`, `FieldSchema` interfaces
- Port registry (`constructs/portRegistry.ts`) manages port schemas with polarity-based validation (receives schemas as parameter)
- Built-in schemas (`constructs/schemas/built-ins.ts`) for common constructs with builtInConstructSchemas and builtInPortSchemas arrays
- User-defined schemas and port schemas stored in Yjs document
- Schema creation via SchemaCreationWizard (multi-step wizard accessible from context menu)
- Port creation via MetamapConnectionModal (when connecting schemas in Metamap view)
- **Hosting modes**: Static (single local document) or Server (collaboration with ?doc= routing)
- **Does NOT know** about React Flow or how nodes are rendered

### 3. Compiler Layer (`src/constructs/compiler/`)
- Transforms visual canvas into text output
- Pure function - takes schemas and deployables as explicit parameters
- Format-specific compilers in `formatters/`: JSON
- Groups nodes by type and applies appropriate formatters
- **Does NOT know** about the visual editor or how constructs were created
- **No global state**: All dependencies passed as function parameters

## Why This Separation Matters

1. **Visual Editor** can add new features (multi-select, keyboard shortcuts, themes) without touching construct logic
2. **Construct Registry** can add new construct types without modifying the editor or compiler
3. **Compiler** can add new output formats without changing how constructs are defined or rendered
4. **User-defined constructs** work seamlessly because all three layers interact through well-defined interfaces

## Key Concepts

### Construct Schema
A `ConstructSchema` defines a construct TYPE (e.g., "REST Controller", "Database Table"). It includes:
- Type identifier, display name, category, color
- Field definitions (text, dropdown, table, code, connection types)
- `displayField` - which field's value to show as node title
- Compilation configuration (format, template, section header)
- Optional `semanticDescription` (shown in compiled output as AI context)

### Construct Instance
A React Flow node containing:
- Reference to its schema type
- `semanticId` - required unique identifier (e.g., "controller-abc123")
- Field values (the actual data entered by the user)
- Connections array (port-to-port links to other constructs)
- UI state (expanded/collapsed)

**Note:** There is no `name` field. Node titles are derived from either the `displayField` value or `semanticId`.

### Deployables
**Deployables** are logical groupings that allow users to organize constructs into deployment units. Each construct can be assigned to a deployable (or "none"), helping AI tools understand which components should be deployed together.

Examples of deployables:
- API Service (contains controllers, models, middleware)
- Database Layer (contains tables, migrations, connection logic)
- UI Application (contains components, routes, assets)
- CDK Stack (contains infrastructure definitions)

Deployables are compiled into the output as metadata, helping AI tools generate code that respects deployment boundaries.

### Ports & Connections

**See:** `.cursor/rules/ports-and-connections.mdc` for full design philosophy.

Constructs connect via **ports**—typed attachment points that determine relationship semantics:

- **Port schemas**: Define port types with polarity (`source`, `sink`, `bidirectional`, `relay`, `intercept`)
- **Built-in ports**: `flow-in`, `flow-out`, `parent`, `child`, `symmetric`, `intercept`, `relay`
- **Two-step validation**: (1) Block same-direction pairs (relay=source, intercept=sink); (2) Skip compatibleWith for relay/intercept/bidirectional, require match for plain source+sink
- **Storage**: All connection data lives on constructs, not edges
- **Interpretation**: Direction derives from port ownership and polarity, not edge metadata
- **User-extensible**: Port schemas stored in document store, editable via Metamap view

Example: A `Constraint` with a `flow-out` port (source polarity) connecting to a `Table`'s `flow-in` port (sink polarity) means "Constraint references Table" (and inversely, "Table is referenced by Constraint").

### AI-Friendly Semantic Linking

Carta produces **AI-optimized output** that goes beyond basic JSON representation:

#### Semantic Identifiers
Constructs get **semantic IDs** that are meaningful to both humans and AI:
- `"controller-abc123"` - Generated from type + timestamp + random suffix
- Used as primary identifier throughout the system

#### Relationship Metadata
The compiler analyzes all connections (edges) and adds bidirectional relationship metadata:
```json
{
  "id": "controller-abc123",
  "references": ["database-xyz789", "service-def456"],
  "type": "controller"
}
```

```json
{
  "id": "database-xyz789",
  "referencedBy": ["controller-abc123"],
  "type": "database"
}
```

This allows AI tools to:
1. **Understand Dependencies**: Know which components depend on others
2. **Generate Code Structure**: Create appropriate import statements and initialization order
3. **Respect Deployment Boundaries**: Group related constructs within deployables
4. **Navigate Relationships**: Traverse the architecture graph bidirectionally

#### Compilation Process
1. **Visual Design** → User creates nodes and connections in the canvas
2. **Relationship Analysis** → Compiler analyzes edges to build dependency maps
3. **Semantic Enhancement** → Nodes get semantic IDs and relationship metadata
4. **Structured Output** → JSON output with AI-friendly identifiers and relationship context

### Dynamic Rendering
`ConstructNode.tsx` is a single generic component that:
1. Receives a construct instance (node data)
2. Fetches its schema from the registry
3. Uses `getDisplayName()` to derive node title from displayField or semanticId
4. Dynamically renders fields based on the schema
5. Works for ANY construct type (built-in or user-defined)

## Data Flow

```
User adds node → useDocument() fetches schema from adapter → Visual editor creates node instance with semanticId
User edits fields → Node data updated → Synced to Yjs Y.Doc via adapter → Persisted to IndexedDB
User assigns deployable → Construct gets deployable grouping → Stored in adapter
User drags port to port → portRegistry.canConnect() validates → Connection stored on source construct → Edge rendered
User clicks Compile → Compiler receives schemas/deployables as params → Generates relationship semantics → AI-friendly output
User opens Metamap → Can view/edit schemas + create connections with ports → Saves to Yjs Y.Doc via adapter → New types available
User imports file → Document cleared via adapter → New data loaded (like Excalidraw)
```

**Connection flow detail:** See `.cursor/rules/ports-and-connections.mdc`

## File Structure

### Layout Components
- `/src/App.tsx` - Root component, owns layout and coordinates state, Map/Metamap view toggle
- `/src/components/Header.tsx` - Project title, import/export, Map/Metamap toggle, settings, Share (server mode)
- `/src/components/Map.tsx` - ReactFlow canvas for instance view (nodes, edges, virtual parents)
- `/src/components/Metamap.tsx` - ReactFlow canvas for schema-level metamodel view
- `/src/components/Footer.tsx` - Footer bar

### Header & Modals
- `/src/components/ProjectInfoModal.tsx` - Modal for editing project title and description
- `/src/components/ExamplesModal.tsx` - Modal for loading bundled example projects
- `/src/components/DocumentBrowserModal.tsx` - Document browser/selector (server mode)
- `/src/components/ConnectionStatus.tsx` - Connection status indicator (server mode)

### Metamap Components
- `/src/components/SchemaNode.tsx` - Renders construct schemas with port diamonds in Metamap
- `/src/components/SchemaGroupNode.tsx` - Renders schema groups in Metamap
- `/src/components/MetamapConnectionModal.tsx` - Modal for creating schema connections (port color picker)
- `/src/components/SchemaPreview.tsx` - Schema preview rendering

### Wizards & Reusable UI
- `/src/components/SchemaCreationWizard.tsx` - Multi-step wizard for creating/editing construct schemas
- `/src/components/ui/WizardModal.tsx` - Reusable multi-step wizard modal shell

### Other Components
- `/src/components/ConstructNode.tsx` - Generic node renderer for constructs
- `/src/components/VirtualParentNode.tsx` - Visual grouping container node (expandable/collapsible)
- `/src/ContextMenu.tsx` - Shared context menu: instance ops optional (Map view), schema ops always available (Metamap view)
- `/src/components/` - Modals, menus, field editors

### Domain Logic
- `/src/constructs/types.ts` - Core TypeScript interfaces: PortSchema, FieldSchema, Polarity (5 values), VirtualParentNodeData, CartaDocument, DocumentAdapter, SchemaGroup
- `/src/constructs/portRegistry.ts` - Port schema registry with two-step polarity-based validation (accepts schemas as param)
- `/src/constructs/schemas/built-ins.ts` - Built-in construct and port schema definitions
- `/src/constructs/compiler/` - Compilation engine (pure functions with explicit parameters)
- `/src/contexts/DocumentContext.tsx` - Document provider managing Yjs adapter lifecycle
- `/src/stores/adapters/yjsAdapter.ts` - Yjs implementation of DocumentAdapter interface
- `/src/hooks/useDocument.ts` - Primary hook for accessing all document state and operations

### Utilities
- `/src/utils/cartaFile.ts` - Export/import utilities with semantic ID generation
- `/src/utils/displayUtils.ts` - `getDisplayName()` helper for node titles
- `/src/utils/examples.ts` - Load bundled example .carta files using Vite's import.meta.glob
- `/src/hooks/` - Custom React hooks (undo/redo)
- `/src/main.tsx` - Entry point, configures staticMode from VITE_STATIC_MODE env var
- `/src/index.css` - Tailwind + custom styles

## Testing

**All tests must pass before committing changes.**

```bash
npm run test          # Integration tests (Vitest)
npm run test:e2e      # E2E tests (Playwright)
```

If tests fail after your changes, fix them before proceeding.
