---
alwaysApply: true
---

# Carta - Visual Software Architecture Editor

## Project Overview

Carta is a node-based visual editor for designing software architecture. Users can create, connect, and configure software components (called "Constructs") in a visual canvas, then compile the entire design into text output that can be fed into AI coding tools.

**Core Goal**: Bridge the gap between high-level architecture design and AI-assisted code generation by providing a visual interface that produces structured, machine-readable specifications.

## Key Libraries & Technologies

- **React 19.2** - UI framework
- **@xyflow/react 12.10** (React Flow) - Node-based visual editor with drag-drop, connections, and pan/zoom
- **Vite 7.2** - Build tool and dev server
- **TypeScript 5.9** - Type safety
- **Tailwind CSS** - Utility-first styling
- **Yjs** - CRDT-based state management with collaborative editing support
- **y-indexeddb** - Local persistence layer for Yjs documents
- **y-websocket** (optional) - WebSocket provider for real-time collaboration

## Architecture: Separation of Concerns

The system is designed with **three decoupled layers** that can evolve independently:

### 1. Visual Editor Layer (`src/App.tsx`, `src/components/`)
- Manages the React Flow canvas (nodes, edges, viewport)
- Handles user interactions (drag, connect, select, copy/paste)
- Provides UI controls (toolbar, context menus, node controls)
- Implements undo/redo functionality
- **Does NOT know** how to render specific construct types or compile them

#### UI Layout (IDE-style)
The application uses a split-panel layout with a right-side drawer:

```
┌─────────────────────────────────────────┐
│               Header                     │
│  (project title, import/export)          │
├─────────────────────────────────────────┤
│                                          │
│               Map                        │
│  (ReactFlow canvas, zoom controls,       │
│   add construct, node interactions)      │
│                                          │
│                              ┌───────────┤
│                              │ [C] Drawer│
│                              │ [P] Tabs  │
│                              │ [G] Float │
│                              │ [D] Right │
│                              │           │
└──────────────────────────────┴───────────┘
```

**Components:**
- **App** - Owns the layout, manages view state, handles import/export, shows DocumentBrowserModal when required
- **Header** - Project title (click to edit via modal), import/export buttons, theme selector, settings menu, Share button (server mode only)
  - **ProjectInfoModal** - Edit project title and description
  - **ExamplesModal** - Load bundled example .carta files from `/examples/` directory
  - **DocumentBrowserModal** - Browse/create/select documents in server mode, required mode when ?doc= missing
  - **ConnectionStatus** - Connection status indicator (server mode only)
- **Map** - ReactFlow canvas with zoom controls, node operations, context menus, SchemaCreationWizard
  - **SchemaCreationWizard** - Multi-step wizard for creating/editing construct schemas (Basics, Fields, Ports)
  - **ContextMenu** (`src/ContextMenu.tsx`) - Canvas right-click menu with "New Construct Schema" option
- **Drawer** - Right-side slide-out panel with floating tab buttons
  - **ConstructEditor** - CRUD for construct schemas
  - **PortSchemaEditor** - CRUD for port schemas (port type definitions)
  - **SchemaGroupEditor** - CRUD for schema grouping
  - **DeployablesEditor** - CRUD for deployables

**State Flow:**
- `selectedNodeIds` lifted to App, shared between Map and Drawer
- Drawer slides in from right with backdrop overlay
- Floating tab buttons remain visible even when drawer is closed

### 2. Document Adapter Layer (`src/stores/`)
- DocumentAdapter interface defines contract for all state operations
- YjsAdapter (`adapters/yjsAdapter.ts`) implements adapter using Yjs Y.Doc
- DocumentContext (`contexts/DocumentContext.tsx`) manages adapter lifecycle and mode detection (static vs server)
- Schema system (`constructs/types.ts`) defines structure via `ConstructSchema`, `PortSchema`, `FieldSchema` interfaces
- Port registry (`constructs/portRegistry.ts`) manages port schemas with polarity-based validation (receives schemas as parameter)
- Built-in schemas (`constructs/schemas/built-ins.ts`) for common constructs with builtInConstructSchemas and builtInPortSchemas arrays
- User-defined schemas and port schemas stored in Yjs document
- Schema Editor (`components/ConstructEditor.tsx`) allows users to create custom constructs
- Port Schema Editor (`components/PortSchemaEditor.tsx`) allows users to create custom port types
- **Hosting modes**: Static (single local document) or Server (collaboration with ?doc= routing)
- **Does NOT know** about React Flow or how nodes are rendered

### 3. Compiler Layer (`src/constructs/compiler/`)
- Transforms visual canvas into text output
- Pure function - takes schemas and deployables as explicit parameters
- Format-specific compilers in `formatters/`: JSON
- Groups nodes by type and applies appropriate formatters
- **Does NOT know** about the visual editor or how constructs were created
- **No global state**: All dependencies passed as function parameters

## Why This Separation Matters

1. **Visual Editor** can add new features (multi-select, keyboard shortcuts, themes) without touching construct logic
2. **Construct Registry** can add new construct types without modifying the editor or compiler
3. **Compiler** can add new output formats without changing how constructs are defined or rendered
4. **User-defined constructs** work seamlessly because all three layers interact through well-defined interfaces

## Key Concepts

### Construct Schema
A `ConstructSchema` defines a construct TYPE (e.g., "REST Controller", "Database Table"). It includes:
- Type identifier, display name, category, color
- Field definitions (text, dropdown, table, code, connection types)
- `displayField` - which field's value to show as node title
- Compilation configuration (format, template, section header)
- Optional `semanticDescription` (shown in compiled output as AI context)

### Construct Instance
A React Flow node containing:
- Reference to its schema type
- `semanticId` - required unique identifier (e.g., "controller-abc123")
- Field values (the actual data entered by the user)
- Connections array (port-to-port links to other constructs)
- UI state (expanded/collapsed)

**Note:** There is no `name` field. Node titles are derived from either the `displayField` value or `semanticId`.

### Deployables
**Deployables** are logical groupings that allow users to organize constructs into deployment units. Each construct can be assigned to a deployable (or "none"), helping AI tools understand which components should be deployed together.

Examples of deployables:
- API Service (contains controllers, models, middleware)
- Database Layer (contains tables, migrations, connection logic)
- UI Application (contains components, routes, assets)
- CDK Stack (contains infrastructure definitions)

Deployables are compiled into the output as metadata, helping AI tools generate code that respects deployment boundaries.

### Ports & Connections

**See:** `.cursor/rules/ports-and-connections.mdc` for full design philosophy.

Constructs connect via **ports**—typed attachment points that determine relationship semantics:

- **Port schemas**: Define port types with polarity (`source`, `sink`, `bidirectional`)
- **Built-in ports**: `flow-in`, `flow-out`, `parent`, `child`, `symmetric`, `intercept`, `forward`
- **Polarity-based validation**: Prevents invalid connections (source-source, sink-sink)
- **Wildcard support**: `*`, `*source*`, `*sink*` for flexible compatibility rules
- **Storage**: All connection data lives on constructs, not edges
- **Interpretation**: Direction derives from port ownership and polarity, not edge metadata
- **User-extensible**: Port schemas stored in document store, editable via Ports tab

Example: A `Constraint` with a `flow-out` port (source polarity) connecting to a `Table`'s `flow-in` port (sink polarity) means "Constraint references Table" (and inversely, "Table is referenced by Constraint").

### AI-Friendly Semantic Linking

Carta produces **AI-optimized output** that goes beyond basic JSON representation:

#### Semantic Identifiers
Constructs get **semantic IDs** that are meaningful to both humans and AI:
- `"controller-abc123"` - Generated from type + timestamp + random suffix
- Used as primary identifier throughout the system

#### Relationship Metadata
The compiler analyzes all connections (edges) and adds bidirectional relationship metadata:
```json
{
  "id": "controller-abc123",
  "references": ["database-xyz789", "service-def456"],
  "type": "controller"
}
```

```json
{
  "id": "database-xyz789",
  "referencedBy": ["controller-abc123"],
  "type": "database"
}
```

This allows AI tools to:
1. **Understand Dependencies**: Know which components depend on others
2. **Generate Code Structure**: Create appropriate import statements and initialization order
3. **Respect Deployment Boundaries**: Group related constructs within deployables
4. **Navigate Relationships**: Traverse the architecture graph bidirectionally

#### Compilation Process
1. **Visual Design** → User creates nodes and connections in the canvas
2. **Relationship Analysis** → Compiler analyzes edges to build dependency maps
3. **Semantic Enhancement** → Nodes get semantic IDs and relationship metadata
4. **Structured Output** → JSON output with AI-friendly identifiers and relationship context

### Dynamic Rendering
`ConstructNode.tsx` is a single generic component that:
1. Receives a construct instance (node data)
2. Fetches its schema from the registry
3. Uses `getDisplayName()` to derive node title from displayField or semanticId
4. Dynamically renders fields based on the schema
5. Works for ANY construct type (built-in or user-defined)

## Data Flow

```
User adds node → useDocument() fetches schema from adapter → Visual editor creates node instance with semanticId
User edits fields → Node data updated → Synced to Yjs Y.Doc via adapter → Persisted to IndexedDB
User assigns deployable → Construct gets deployable grouping → Stored in adapter
User drags port to port → portRegistry.canConnect() validates → Connection stored on source construct → Edge rendered
User clicks Compile → Compiler receives schemas/deployables as params → Generates relationship semantics → AI-friendly output
User opens Construct Editor → Can view/edit schemas + ports → Saves to Yjs Y.Doc via adapter → New types available
User imports file → Document cleared via adapter → New data loaded (like Excalidraw)
```

**Connection flow detail:** See `.cursor/rules/ports-and-connections.mdc`

## File Structure

### Layout Components
- `/src/App.tsx` - Root component, owns layout and coordinates state
- `/src/components/Header.tsx` - Project title and import/export controls
- `/src/components/Map.tsx` - ReactFlow canvas with node operations
- `/src/components/Drawer.tsx` - Right-side slide-out panel with floating tabs
- `/src/components/DrawerTabs.tsx` - Tab type definitions for drawer navigation

### Header Components
- `/src/components/ProjectInfoModal.tsx` - Modal for editing project title and description
- `/src/components/ExamplesModal.tsx` - Modal for loading bundled example projects
- `/src/components/DocumentBrowserModal.tsx` - Document browser/selector (server mode)
- `/src/components/ConnectionStatus.tsx` - Connection status indicator (server mode)

### Drawer Views
- `/src/components/ConstructEditor.tsx` - CRUD for construct schemas
- `/src/components/PortSchemaEditor.tsx` - CRUD for port schemas
- `/src/components/SchemaGroupEditor.tsx` - CRUD for schema grouping
- `/src/components/DeployablesEditor.tsx` - CRUD for deployables

### Wizards & Reusable UI
- `/src/components/SchemaCreationWizard.tsx` - Multi-step wizard for creating/editing construct schemas
- `/src/components/ui/WizardModal.tsx` - Reusable multi-step wizard modal shell

### Other Components
- `/src/components/ConstructNode.tsx` - Generic node renderer for constructs
- `/src/ContextMenu.tsx` - Canvas right-click context menu (New Construct Schema, etc.)
- `/src/components/` - Modals, menus, field editors

### Domain Logic
- `/src/constructs/types.ts` - Core TypeScript interfaces: PortSchema, FieldSchema, Polarity, CartaDocument, DocumentAdapter, SchemaGroup
- `/src/constructs/portRegistry.ts` - Port schema registry with polarity-based validation, wildcard matching (accepts schemas as param)
- `/src/constructs/schemas/built-ins.ts` - Built-in construct and port schema definitions
- `/src/constructs/compiler/` - Compilation engine (pure functions with explicit parameters)
- `/src/contexts/DocumentContext.tsx` - Document provider managing Yjs adapter lifecycle
- `/src/stores/adapters/yjsAdapter.ts` - Yjs implementation of DocumentAdapter interface
- `/src/hooks/useDocument.ts` - Primary hook for accessing all document state and operations

### Utilities
- `/src/utils/cartaFile.ts` - Export/import utilities with semantic ID generation
- `/src/utils/displayUtils.ts` - `getDisplayName()` helper for node titles
- `/src/utils/examples.ts` - Load bundled example .carta files using Vite's import.meta.glob
- `/src/hooks/` - Custom React hooks (undo/redo)
- `/src/main.tsx` - Entry point, configures staticMode from VITE_STATIC_MODE env var
- `/src/index.css` - Tailwind + custom styles

## Testing

**All tests must pass before committing changes.**

```bash
npm run test          # Integration tests (Vitest)
npm run test:e2e      # E2E tests (Playwright)
```

If tests fail after your changes, fix them before proceeding.
