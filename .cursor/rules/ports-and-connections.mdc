---
description: Port and connection model design philosophy
globs: ["**/constructs/**", "**/components/ConstructNode*", "**/components/SchemaEditor*", "**/compiler/**"]
---

# Port & Connection Model Design Philosophy

## Core Principle: Symmetric Storage, Asymmetric Interpretation

Connections are **symmetric in storage** but **asymmetric in interpretation**. The edge itself carries no metadata—direction and meaning derive entirely from **which construct owns which port type**.

## Port Types

Seven built-in port schemas defined in `PortSchema` (M1 layer):

| Port Type | Purpose | Polarity | Default Position | Color |
|-----------|---------|----------|------------------|-------|
| `flow-in` | Receives flow | sink | Left | #3b82f6 (blue) |
| `flow-out` | Emits flow | source | Right | #22c55e (green) |
| `parent` | Has children | source | Bottom | #8b5cf6 (violet) |
| `child` | Belongs to parent | sink | Top | #8b5cf6 (violet) |
| `symmetric` | Bidirectional peer | bidirectional | Right | #64748b (slate) |
| `intercept` | Pass-through input | sink | Left | #f59e0b (amber) |
| `forward` | Pass-through output | source | Right | #f59e0b (amber) |

## Polarity-Based Validation

Port connections are validated using polarity and compatibility rules:

```typescript
interface PortSchema {
  id: string;
  displayName: string;
  semanticDescription: string;
  polarity: 'source' | 'sink' | 'bidirectional';
  compatibleWith: string[];  // port IDs or wildcards
  expectedComplement?: string;  // UI hint, not validation
  defaultPosition: PortPosition;
  color: string;
}
```

### Polarity Rules
- **source → source**: BLOCKED (both initiate)
- **sink → sink**: BLOCKED (both receive)
- **source → sink**: ALLOWED (normal flow)
- **sink → source**: ALLOWED (user dragged backward)
- **bidirectional → any**: ALLOWED
- **any → bidirectional**: ALLOWED

### Compatibility Table

| Port Type | Polarity | Compatible With |
|-----------|----------|-----------------|
| `flow-in` | sink | `flow-out`, `forward` |
| `flow-out` | source | `flow-in`, `intercept` |
| `parent` | source | `child`, `intercept` |
| `child` | sink | `parent`, `forward` |
| `symmetric` | bidirectional | `*` (wildcard) |
| `intercept` | sink | `*source*` (wildcard) |
| `forward` | source | `*sink*` (wildcard) |

### Wildcard Support
- `*`: matches any port schema
- `*source*`: matches all ports with `polarity: 'source'`
- `*sink*`: matches all ports with `polarity: 'sink'`
- `*bidirectional*`: matches all ports with `polarity: 'bidirectional'`

Validation is bidirectional—if A can connect to B, then B can connect to A.

## Port Registry

The `PortRegistry` class manages port schemas with polarity-based validation:

```typescript
// src/constructs/portRegistry.ts
export const DEFAULT_PORT_SCHEMAS: PortSchema[] = [
  { id: 'flow-in', displayName: 'Flow In', polarity: 'sink', ... },
  { id: 'flow-out', displayName: 'Flow Out', polarity: 'source', ... },
  { id: 'parent', displayName: 'Parent', polarity: 'source', ... },
  { id: 'child', displayName: 'Child', polarity: 'sink', ... },
  { id: 'symmetric', displayName: 'Link', polarity: 'bidirectional', ... },
  { id: 'intercept', displayName: 'Intercept', polarity: 'sink', ... },
  { id: 'forward', displayName: 'Forward', polarity: 'source', ... },
];

export class PortRegistry {
  canConnect(fromPortType: string, toPortType: string): boolean;
  getColor(portType: string): string;
  get(id: string): PortSchema | undefined;
  getAll(): PortSchema[];
  setSchemas(schemas: PortSchema[]): void;  // Sync with document store
  register(schema: PortSchema): void;
  remove(id: string): boolean;
  getDefaultPosition(portType: string): PortPosition;
}

export const portRegistry = new PortRegistry();

// Sync registry with document portSchemas
export function syncWithDocumentStore(portSchemas?: PortSchema[]): void;
```

### Document Store Integration
Port schemas are stored in the Yjs document alongside constructs and deployables. The port registry receives schemas as a parameter and updates its internal state. Components access port schemas via `useDocument()`:

```typescript
const { portSchemas } = useDocument();
// Sync registry when schemas change
syncWithDocumentStore(portSchemas);
```

This enables:
- User-defined port types
- Persistence across sessions via IndexedDB
- Export/import of custom port schemas
- Collaborative editing via Yjs

## Design Decisions

### 1. No Edge Metadata
All connection data lives on the **construct instance**, not the edge. Edges are purely visual.

```typescript
// Connection stored on source construct
interface ConnectionValue {
  portId: string;           // Which port on this construct
  targetSemanticId: string; // Connected construct's semanticId
  targetPortId: string;     // Which port on target
}

interface ConstructNodeData {
  // ...other fields
  connections: ConnectionValue[];
}
```

### 2. Inverse is Always Derivable
You never define `(A → B)` and `(B → A)` separately. A single relationship definition covers both:

- "Database contains Table" ⟺ "Table belongs to Database"
- "Constraint references Table" ⟺ "Table is referenced by Constraint"

If you need different meanings for `(A,B)` vs `(B,A)`, **use different construct types**.

### 3. Port Configuration is Per-Schema
All instances of a construct type share the same ports. Port customization happens in the Schema Editor, not on individual canvas nodes.

```typescript
interface PortConfig {
  id: string;                    // Unique within construct
  portType: string;              // References PortDefinition.id
  position: 'left' | 'right' | 'top' | 'bottom';
  offset: number;                // 0-100% along edge
  label: string;
  description?: string;

  // Type system hooks
  dataType?: string;
  suggestedTypes?: string[];
  suggestedPorts?: string[];
}
```

### 4. Future Type System Hooks
Ports include optional `dataType`, `suggestedTypes`, and `suggestedPorts` fields for future type validation. Today they're ignored; tomorrow they enable:

- Port validates connections based on dataType compatibility
- Dynamic dropdowns based on connected construct's fields
- Compile-time warnings for mismatched types

## Relationship Semantics in Compilation

The compiler generates human-readable relationship descriptions:

```typescript
{
  semanticId: 'constraint-fk-orders-users',
  ports: [
    { id: 'child', portType: 'child', label: 'Parent' },
    { id: 'fk-target', portType: 'flow-out', label: 'References' },
  ],
  connections: [
    { portId: 'child', targetSemanticId: 'table-orders', targetPortId: 'parent' },
    { portId: 'fk-target', targetSemanticId: 'table-users', targetPortId: 'flow-in' },
  ],
  relationships: [
    'Is child of: table-orders',
    'References (via fk-target): table-users',
  ],
}
```

## Test Case: Database Schema

The model should easily express:

```
Database (parent of tables)
    └── Table (child of DB, parent of constraints)
            └── Constraint (child of table, flow-out to referenced table)
```

- **Database**: `child` port (bottom) for tables
- **Table**: `parent` port (top), `child` port (bottom), `flow-in` port (left) for incoming references
- **Constraint**: `parent` port (top), `flow-out` port (right) for FK target

Foreign key details (source column, target column) live in **construct fields**, not on the connection.

## CSS Styling

Port handles are styled via data attributes:

```css
.react-flow__handle[data-port-type="flow-in"] { background: #3b82f6 !important; }     /* blue */
.react-flow__handle[data-port-type="flow-out"] { background: #22c55e !important; }    /* green */
.react-flow__handle[data-port-type="parent"] { background: #8b5cf6 !important; }      /* violet */
.react-flow__handle[data-port-type="child"] { background: #8b5cf6 !important; }       /* violet */
.react-flow__handle[data-port-type="symmetric"] { background: #64748b !important; }   /* slate */
.react-flow__handle[data-port-type="intercept"] { background: #f59e0b !important; }   /* amber */
.react-flow__handle[data-port-type="forward"] { background: #f59e0b !important; }     /* amber */
```

## Necessary and Sufficient

The goal is **minimal primitives** that express all needed relationships:

1. Don't add features unless they enable something impossible before
2. Don't duplicate semantics (if port types give direction, edges don't need it)
3. Prefer structural meaning (port ownership) over explicit metadata

## References

- Academic field: **Metamodeling**, **Domain-Specific Languages**, **Knowledge Graphs**
- Key resource: "Building Knowledge Graphs: A Practitioner's Guide" (Barrasa & Webber, 2023)
