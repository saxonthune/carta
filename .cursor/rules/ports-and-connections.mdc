---
description: Port and connection model design philosophy
globs: ["**/constructs/**", "**/components/ConstructNode*", "**/components/SchemaEditor*", "**/compiler/**"]
---

# Port & Connection Model Design Philosophy

## Core Principle: Symmetric Storage, Asymmetric Interpretation

Connections are **symmetric in storage** but **asymmetric in interpretation**. The edge itself carries no metadata—direction and meaning derive entirely from **which construct owns which port type**.

## Port Types

Five built-in port types defined in `PortDefinition` (M2 layer):

| Port Type | Purpose | Default Position | Color |
|-----------|---------|------------------|-------|
| `flow-in` | Receives flow | Left | #3b82f6 (blue) |
| `flow-out` | Emits flow | Right | #22c55e (green) |
| `parent` | Has children | Top | #f59e0b (amber) |
| `child` | Belongs to parent | Bottom | #f59e0b (amber) |
| `symmetric` | Symmetric association | Right | #8b5cf6 (purple) |

## Compatibility-Based Validation

Port connections are validated using compatibility lists:

```typescript
interface PortDefinition {
  id: string;
  label: string;
  description: string;
  compatibleWith?: string[];  // undefined = any port
  defaultPosition: PortPosition;
  color: string;
}
```

| Port Type | Compatible With |
|-----------|-----------------|
| `flow-in` | `flow-out`, `symmetric` |
| `flow-out` | `flow-in`, `symmetric` |
| `parent` | `child`, `symmetric` |
| `child` | `parent`, `symmetric` |
| `symmetric` | any (compatibleWith: undefined) |

Validation is bidirectional—if A can connect to B, then B can connect to A.

## Port Registry

The `PortRegistry` class manages port definitions:

```typescript
// src/constructs/portRegistry.ts
export const DEFAULT_PORT_DEFINITIONS: PortDefinition[] = [
  { id: 'flow-in', label: 'Flow In', ... },
  { id: 'flow-out', label: 'Flow Out', ... },
  { id: 'parent', label: 'Parent', ... },
  { id: 'child', label: 'Child', ... },
  { id: 'symmetric', label: 'Link', ... },
];

export class PortRegistry {
  canConnect(sourcePortType: string, targetPortType: string): boolean;
  getColor(portType: string): string;
  get(id: string): PortDefinition | undefined;
  getAll(): PortDefinition[];
}

export const portRegistry = new PortRegistry();
```

## Design Decisions

### 1. No Edge Metadata
All connection data lives on the **construct instance**, not the edge. Edges are purely visual.

```typescript
// Connection stored on source construct
interface ConnectionValue {
  portId: string;           // Which port on this construct
  targetSemanticId: string; // Connected construct's semanticId
  targetPortId: string;     // Which port on target
}

interface ConstructNodeData {
  // ...other fields
  connections: ConnectionValue[];
}
```

### 2. Inverse is Always Derivable
You never define `(A → B)` and `(B → A)` separately. A single relationship definition covers both:

- "Database contains Table" ⟺ "Table belongs to Database"
- "Constraint references Table" ⟺ "Table is referenced by Constraint"

If you need different meanings for `(A,B)` vs `(B,A)`, **use different construct types**.

### 3. Port Configuration is Per-Schema
All instances of a construct type share the same ports. Port customization happens in the Schema Editor, not on individual canvas nodes.

```typescript
interface PortConfig {
  id: string;                    // Unique within construct
  portType: string;              // References PortDefinition.id
  position: 'left' | 'right' | 'top' | 'bottom';
  offset: number;                // 0-100% along edge
  label: string;
  description?: string;

  // Type system hooks
  dataType?: string;
  suggestedTypes?: string[];
  suggestedPorts?: string[];
}
```

### 4. Future Type System Hooks
Ports include optional `dataType`, `suggestedTypes`, and `suggestedPorts` fields for future type validation. Today they're ignored; tomorrow they enable:

- Port validates connections based on dataType compatibility
- Dynamic dropdowns based on connected construct's fields
- Compile-time warnings for mismatched types

## Relationship Semantics in Compilation

The compiler generates human-readable relationship descriptions:

```typescript
{
  semanticId: 'constraint-fk-orders-users',
  ports: [
    { id: 'child', portType: 'child', label: 'Parent' },
    { id: 'fk-target', portType: 'flow-out', label: 'References' },
  ],
  connections: [
    { portId: 'child', targetSemanticId: 'table-orders', targetPortId: 'parent' },
    { portId: 'fk-target', targetSemanticId: 'table-users', targetPortId: 'flow-in' },
  ],
  relationships: [
    'Is child of: table-orders',
    'References (via fk-target): table-users',
  ],
}
```

## Test Case: Database Schema

The model should easily express:

```
Database (parent of tables)
    └── Table (child of DB, parent of constraints)
            └── Constraint (child of table, flow-out to referenced table)
```

- **Database**: `child` port (bottom) for tables
- **Table**: `parent` port (top), `child` port (bottom), `flow-in` port (left) for incoming references
- **Constraint**: `parent` port (top), `flow-out` port (right) for FK target

Foreign key details (source column, target column) live in **construct fields**, not on the connection.

## CSS Styling

Port handles are styled via data attributes:

```css
.react-flow__handle[data-port-type="flow-in"] { background: #3b82f6 !important; }
.react-flow__handle[data-port-type="flow-out"] { background: #22c55e !important; }
.react-flow__handle[data-port-type="parent"] { background: #f59e0b !important; }
.react-flow__handle[data-port-type="child"] { background: #f59e0b !important; }
.react-flow__handle[data-port-type="symmetric"] { background: #8b5cf6 !important; }
```

## Necessary and Sufficient

The goal is **minimal primitives** that express all needed relationships:

1. Don't add features unless they enable something impossible before
2. Don't duplicate semantics (if port types give direction, edges don't need it)
3. Prefer structural meaning (port ownership) over explicit metadata

## References

- Academic field: **Metamodeling**, **Domain-Specific Languages**, **Knowledge Graphs**
- Key resource: "Building Knowledge Graphs: A Practitioner's Guide" (Barrasa & Webber, 2023)
